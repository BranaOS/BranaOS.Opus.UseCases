using BranaOS.Opus.Core;

namespace BranaOS.Opus.UseCases;

public interface IRequest<TResponse> { }

public interface IUseCase<in TRequest, TResponse> where TRequest : IRequest<TResponse>
{
  /// <summary>
  /// Validates the request before processing.
  /// </summary>
  /// <param name="request">The request to validate.</param>
  /// <returns>A result indicating success or failure.</returns>
  /// <remarks>
  /// This method is called before the request is processed. If validation fails, the request will not be processed further.
  /// </remarks>
  Task<Result<Nothing>> Validate(TRequest request);
  /// <summary>
  /// Called before the request is processed.
  /// </summary>
  /// <param name="request">The request to process.</param>
  /// <returns>A result containing the request to be processed.</returns>
  /// <remarks>
  /// This method allows for modifications to the request before it is handled. It can be used to enrich the request or perform pre-processing tasks.
  /// </remarks>
  /// <returns>
  /// A result containing the request to be processed. If the result is a failure, the request will not be processed further.
  /// </returns>
  Task<Result<IRequest<TResponse>>> Before(TRequest request);
  /// <summary>
  /// Called after the request has been processed.
  /// </summary>
  /// <param name="request">The request that was processed.</param>
  /// <param name="response">The response generated by processing the request.</param>
  /// <returns>A result containing the response.</returns>
  /// <remarks>
  /// This method allows for post-processing of the response after the request has been handled. It can be used to log the response, modify it, or perform any other necessary actions.
  /// </remarks>
  /// <returns>
  /// A result containing the response. If the result is a failure, it indicates an issue with the post-processing step.
  /// </returns>
  Task<Result<TResponse>> After(TRequest request, TResponse response);
  /// <summary>
  /// Handles the request and returns a response.
  /// </summary>
  /// <param name="request">The request to handle.</param>
  /// <returns>A result containing the response.</returns>
  /// <remarks>
  /// This method is the core of the use case, where the actual business logic is implemented. It processes the request and returns a response.
  /// </remarks>
  /// <returns>
  /// A result containing the response. If the result is a failure, it indicates an issue with handling the request.
  /// </returns>
  Task<Result<TResponse>> Handle(TRequest request);
}

public abstract class UseCase<TRequest, TResponse>
  : IUseCase<TRequest, TResponse>
  where TRequest
    : IRequest<TResponse>
{
  public virtual Task<Result<Nothing>> Validate(TRequest request)
  {
    return Task.FromResult(Result.Ok(Nothing._));
  }

  public virtual Task<Result<IRequest<TResponse>>> Before(TRequest request)
  {
    return Task.FromResult(Result.Ok((IRequest<TResponse>)request));
  }

  public virtual Task<Result<TResponse>> After(TRequest request, TResponse response)
  {
    return Task.FromResult(Result.Ok(response));
  }

  internal async Task<Result<TResponse>> Execute(TRequest request)
  {
    var validationResult = await Validate(request);

    if (validationResult.IsFailure)
    {
      return Result.Fail<TResponse>(validationResult.Errors);
    }

    var beforeResult = await Before(request);

    if (beforeResult.IsFailure)
    {
      return Result.Fail<TResponse>(beforeResult.Errors);
    }

    TRequest newRequest = (TRequest)beforeResult.Value;

    var response = await Handle(newRequest);

    if (response.IsFailure)
    {
      return response;
    }

    var afterResult = await After(newRequest, response.Value);

    if (afterResult.IsFailure)
    {
      return afterResult;
    }

    return Result.Ok(afterResult.Value);
  }

  public abstract Task<Result<TResponse>> Handle(TRequest request);
}